library(sf) # spatial library
library(tidyverse)
library(magrittr) # extra for tidyverse R (%<>% pipe)
library(igraph) # for visualization
library(mapview) # visualization too
require(lwgeom) # to use the function st_startpoint
require(skimr) # to skim dataframes (summary)
rstudioapi::addTheme("https://raw.githubusercontent.com/Patryk27/gruvbox-rstudio/master/gruvbox-dark.rstheme", apply = TRUE)
rstudioapi::addTheme("https://raw.githubusercontent.com/gbogler/Nord-RStudio/master/Nord.rstheme", apply = TRUE)
rstudioapi::addTheme(
themePath = "https://raw.githubusercontent.com/edavidaja/nord-rstudio/master/Nord.rstheme",
apply = TRUE
)
library(sf) # spatial library
library(tidyverse)
library(magrittr) # extra for tidyverse R (%<>% pipe)
library(igraph) # for visualization
library(mapview) # visualization too
require(lwgeom) # to use the function st_startpoint
require(skimr) # to skim dataframes (summary)
# read both datasets and prepare them
# 1. map of montreal
montreal <- st_read("./data/geobase_city_of_montreal.json")
#skimr::skim(montreal)
# 2. data provided by Aurelie. discard all but relevant variables
dat <- read.csv("./data/data_final.csv",sep = ';') %>%
dplyr::select(x, y, pi, fi, acc)
skimr::skim(dat)
#--------------------------------------
# Step 2: Make both dataset have matching longitude+latitude (geometry in sf objects)
# type of json data
st_geometry_type(montreal,F)
st_crs(montreal$geometry)
# convert dat into sf
dat.sf <- st_as_sf(
dat,
coords = c("x","y"),
crs = 2950 # the original one in the data based on trial&error
)
montreal %<>% st_transform(crs = 2950) # to match each other dataset
#---------------------------------------
# testing/checking the dat, geometry is correct and
#   we didn't make a mistake above
mapview(dat.sf)
mapview(montreal)
#-------------------------------------
# step 3 works on montreal dataset only.
# step 3.a: working on Montreal only. Extract all intersections as nodes.
# extract start/end locations of streets from montreal.
# geometry has many points (x,y) so we pick the min and max as start/end
montreal %<>%
mutate(start_pt = lwgeom::st_startpoint(geometry),
end_pt = lwgeom::st_endpoint(geometry))
# create an sf object with only those points, keep only distinct rows
# and add an id column
# note that node.sf is basically the network nodes (the montreal. Aurelie's, is
# "supposed to be" a small subset of it)
nodes.sf <- st_sf(
geometry = c(
st_geometry(montreal$start_pt),
st_geometry(montreal$end_pt)),
crs =  2950 #st_crs(montreal)
) %>%
distinct() %>%
mutate(node.id = row_number())
head(nodes.sf)
#------------------------------------------------------------
# step 3.b: since we later need that each start/end point to have a unique id, [which is
# what we did above], we now put this new id column back into montreal df.
# note that there will be an id for the start point and id for the end point.
montreal %<>%
left_join(
nodes.sf %>% rename(geom_node = geometry) %>%
as.data.frame() %>% rename(node_id_start = node.id),
by = c("start_pt" = "geom_node")
) %>%
left_join(
nodes.sf %>% rename(geom_node = geometry) %>%
as.data.frame() %>% rename(node_id_end = node.id),
by = c("end_pt" = "geom_node")
)
# since the data is divided into road segment, the length is computed by the list
# of geometry points. Note to Xinyi, this could be use as weight. there are other
# distance functions too than st_length(e.g., st_area, st_perimeter). Check the help page.
montreal$segment_length <- st_length(montreal$geometry)
#---------------------------------------------------------------------------
# step 3.c: edges are street segments defined by the starting point (by its id),
# the end point and length of that segment as we defined it above.
edges <- montreal %>%
dplyr::select(node_id_start, node_id_end, segment_length) %>%
st_set_geometry(NULL)
# confirm that we didn't do a mistake above
all(edges$node_id_start == edges$node_id_end)
# define the grand graph. our graph should be only a subset of it.
g <- graph_from_data_frame(
d = edges,
directed = FALSE,
vertices = nodes.sf %>%
st_set_geometry(NULL)  # If you want node attributes
)
# weight is the length
E(g)$weight <- edges$segment_length
# check the degree distribution
deg <- degree(g)
print("Grand Graph degree distribution:")
table(deg)
#------------------------------------------------------------------------
# step 4:  Take the subset of graph G that we're interested in.
# associate each intersection in the dataset with its closest point in montreal.
dat.sf$node_id <- st_nearest_feature(dat.sf, nodes.sf)
# edges.s will contain the subset of edges that we want.
edges.s <- montreal %>%
dplyr::select(node_id_start, node_id_end, segment_length, geometry) %>%
filter(node_id_start %in% dat.sf$node_id) %>%
distinct(node_id_start, node_id_end, .keep_all=T)
problematic <- edges.s %>% filter(!node_id_end %in% dat.sf$node_id)
# the following part of the code didn't work so ignore it. an alternative method is used
# now the problem is that not all node_id_end are in our small dataset.
# however, we shoulding also ignore them since we could construct a walk such that
# the two nodes are eventuall connected start1 -> end1 = start2 -> end2 = our target
# get a list of these nodes:
dim(problematic)
# the following loop does this but unfortunately, no nodes are found.
for(i in seq_len(nrow(problematic))){
edges %>%
filter(problematic[i,]$node_id_end == node_id_start) -> t
target = -1
for(j in seq_len(nrow(t))){
if(t[j,]$node_id_end %in% dat.sf$node_id){
target = t[j,]$node_id_end
break
}
if(target!=-1) print(target)
}
}
problematic$node_id_end2 <-
st_nearest_feature(problematic, dat.sf)
# now  put them back in edges
# first get rid of geometry
edges.s %<>% select(-geometry) %>% st_set_geometry(NULL)
problematic %<>% select(-geometry) %>% st_set_geometry(NULL)
edges.s %>%
left_join(
problematic, by = c('node_id_start', 'node_id_end'),
) %>%
mutate(node_id_end = ifelse( is.na(node_id_end2),
node_id_end,
node_id_end2),
segment_length.x = ifelse( is.na(node_id_end2),
segment_length.x,
segment_length.y)) %>%
select(-node_id_end2, -segment_length.y) %>%
rename(segment_length = segment_length.x) ->
edges.final
# finally our list of nodes is
nodes.s <-
dat.sf %>%
select(geometry, node_id) %>%
distinct()
#------------------------------------------------
# we now build the small network
gsmall <- graph_from_data_frame(
d = edges.final,
directed = FALSE,
vertices = nodes.s %>%
st_set_geometry(NULL)  # If you want node attributes
)
#----------------------------------------------
# verification step
# we now have nodes.s and edges.final for our small network
# we hope that all nodes have at least one edges and on average 2.
edges.s %>% head()
#----------------------------------------------
# verification step
# we now have nodes.s and edges.final for our small network
# we hope that all nodes have at least one edges and on average 2.
# 1. verify that all our start-end edges are within the list of nodes
all.edge.nodes <- unique(c(edges.final$node_id_start,
edges.final$node_id_end))
all(all.edge.nodes %in% nodes.s$node_id)
(!all.edge.nodes %in% nodes.s$node_id)
nodes.s %>%
filter(! (node_id %in% all.edge.nodes) )
edges.final %>%
filter( !(node_id_start %in% nodes.s$node_id) |
!(node_id_end %in% nodes.s$node_id) )
View(nodes.s)
dat.sf
dat
dat %>% dim()
dat.sf %>% dim()
nodes.s %>% dim()
edges.s <- montreal %>%
dplyr::select(node_id_start, node_id_end, segment_length, geometry) %>%
filter(node_id_start %in% dat.sf$node_id) %>%
distinct(node_id_start, node_id_end, .keep_all=T)
problematic <- edges.s %>% filter(!node_id_end %in% dat.sf$node_id)
length(problematic)
dim(problematic)
problematic[1,]
#-----------ignore the loop above----------------------------------------------
# alternatively, since about 40% of our network is not connected
# we will -temporarily, pick the nearest end notes for those nodes:
problematic$node_id_end2 <-
st_nearest_feature(problematic, dat.sf)
problematic[1,]
dat.sf[326,]
i=3
nearest_feature_id <-
st_nearest_feature(problematic[i,],filter(dat.sf, geometry!=problematic[i,]$geometry) )
nearest_feature_id
#-----------ignore the loop above----------------------------------------------
# alternatively, since about 40% of our network is not connected
# we will -temporarily, pick the nearest end notes for those nodes:
problematic$node_id_end2 = NA
dim(dat.sf)
problematic$node_id_end2[i,] <- dat.sf[nearest_feature_id,]$node_id
dat.sf[nearest_feature_id,]$node_id
problematic$node_id_end2[i] <- dat.sf[nearest_feature_id,]$node_id
problematic$node_id_end2 = NA
for(i in seq_len(nrow(problematic))){
nearest_feature_id <-
st_nearest_feature(problematic[i,],filter(dat.sf, geometry!=problematic[i,]$geometry) )
problematic$node_id_end2[i] <- dat.sf[nearest_feature_id,]$node_id
}
i
remotes::install_github("tallguyjenks/gruvboxr")
install.packages("remotes")
remotes::install_github("tallguyjenks/gruvboxr")
gruvboxr::install_theme()
